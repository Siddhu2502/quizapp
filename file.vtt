WEBVTT

1
00:00:00.600 --> 00:00:02.900
Welcome to the module regular expression.

2
00:00:05.300 --> 00:00:08.800
After completing this module will be able to Define regular

3
00:00:08.800 --> 00:00:11.300
expression make use of pattern and

4
00:00:11.300 --> 00:00:14.500
marcher clause and perform validation using string Methods

5
00:00:14.500 --> 00:00:15.900
using regular expression.

6
00:00:18.100 --> 00:00:21.500
Regular expression was introduced in Java version 4

7
00:00:21.500 --> 00:00:24.600
regular expression is used for defining string

8
00:00:24.600 --> 00:00:28.300
patterns, which can then be used for searching manipulating and

9
00:00:28.300 --> 00:00:31.500
editing a text. These expressions are also

10
00:00:31.500 --> 00:00:35.000
known as regex short form of regular Expressions

11
00:00:34.300 --> 00:00:37.900
example of a regular expression pattern

12
00:00:37.900 --> 00:00:40.300
a minus said plus which can be used

13
00:00:40.300 --> 00:00:42.900
to match a sequence of lowercase alphabets.

14
00:00:45.900 --> 00:00:48.500
The API for regular expression is available

15
00:00:48.500 --> 00:00:51.400
in java.util.triguex package.

16
00:00:51.400 --> 00:00:54.700
It has one interface and three classes. The

17
00:00:54.700 --> 00:00:57.800
classes are pattern matcha Patton

18
00:00:57.800 --> 00:00:58.600
syntax exception.

19
00:01:01.600 --> 00:01:04.400
A pattern object is a compiled version of

20
00:01:04.400 --> 00:01:07.300
regular expression. This class does not

21
00:01:07.300 --> 00:01:10.500
have a Constructor. So the object for this class

22
00:01:10.500 --> 00:01:13.400
is created using the static method compiled in

23
00:01:13.400 --> 00:01:16.100
the pattern class for this method. We have to

24
00:01:16.100 --> 00:01:19.500
pass the regular expression pattern that needs to

25
00:01:19.500 --> 00:01:19.900
be compared.

26
00:01:20.800 --> 00:01:23.800
Matcha object is a regular expression engine

27
00:01:23.800 --> 00:01:26.500
that interprets the pattern and marches the

28
00:01:26.500 --> 00:01:29.800
regular expression against the text like pattern.

29
00:01:29.800 --> 00:01:32.600
This class also does not have a Constructor.

30
00:01:32.600 --> 00:01:35.600
The object is created using the pattern object

31
00:01:35.600 --> 00:01:38.600
pattern has a method called marches which

32
00:01:38.600 --> 00:01:42.000
takes the string that needs to be compared as input. Thus

33
00:01:41.500 --> 00:01:44.200
Macho macher equals

34
00:01:44.200 --> 00:01:47.300
pattern dot marches of the text that is to be compared and

35
00:01:47.300 --> 00:01:48.600
is passed as parameter.

36
00:01:51.400 --> 00:01:54.400
Consider the sample program an object is

37
00:01:54.400 --> 00:01:57.400
created for pattern with the regular expression pattern to

38
00:01:57.400 --> 00:02:00.400
be compared. Next an object is created for

39
00:02:00.400 --> 00:02:03.700
marcher where we have passed the string that is to be compared and

40
00:02:03.700 --> 00:02:06.200
we have used few methods of marcher for performing the

41
00:02:06.200 --> 00:02:09.300
check the matcha methods test whether the regular

42
00:02:09.300 --> 00:02:12.100
expression matches the pattern here we have

43
00:02:12.100 --> 00:02:13.600
used a method find

44
00:02:14.200 --> 00:02:17.400
Method finds the next expression that matches the

45
00:02:17.400 --> 00:02:17.700
pattern.

46
00:02:18.400 --> 00:02:22.400
Also, we have used one more method group group method

47
00:02:21.400 --> 00:02:23.800
Returns the Matched subsequence.

48
00:02:27.200 --> 00:02:30.500
The character classes are used to define what characters the

49
00:02:30.500 --> 00:02:33.400
pattern should look for the table here depicts the

50
00:02:33.400 --> 00:02:36.500
regular expression description of what that regular

51
00:02:36.500 --> 00:02:39.600
expression does along with an example for each and

52
00:02:39.600 --> 00:02:41.000
every pattern that can be used.

53
00:02:44.200 --> 00:02:47.300
The example code explains how the character classes can

54
00:02:47.300 --> 00:02:48.400
be used in a program.

55
00:02:50.700 --> 00:02:53.400
Like character classes. We have something called as

56
00:02:53.400 --> 00:02:54.300
quantifiers.

57
00:02:54.900 --> 00:02:57.200
This quantifiers specifies the number of

58
00:02:57.200 --> 00:02:58.500
occurrence of a character.

59
00:02:59.300 --> 00:03:02.600
For example, if I say the name of a person it should contain only

60
00:03:02.600 --> 00:03:05.200
alphabets so I can give it as a to z

61
00:03:05.200 --> 00:03:08.100
but not only a to zed. If it is a to z it

62
00:03:08.100 --> 00:03:11.600
will accept only one character, but it can accept multiple characters.

63
00:03:11.600 --> 00:03:14.100
So I have to write with a bracket A

64
00:03:14.100 --> 00:03:17.400
to Z followed by a plus dot which means occurrences one

65
00:03:17.400 --> 00:03:20.700
or more times the table here represents the various

66
00:03:20.700 --> 00:03:23.300
quantifiers that are available for a regular expression.

67
00:03:26.500 --> 00:03:29.800
If we have to match for digits alone use within brackets

68
00:03:29.800 --> 00:03:31.100
as 0 to 9.

69
00:03:31.700 --> 00:03:34.200
Similarly for alphabets A to Z or

70
00:03:34.200 --> 00:03:37.400
A to Z use it within brackets as small AZ and

71
00:03:37.400 --> 00:03:40.200
capital A to Z but there are some short codes that can be

72
00:03:40.200 --> 00:03:43.200
used instead of writing this this we call

73
00:03:43.200 --> 00:03:46.100
as meta characters the various meta characters

74
00:03:46.100 --> 00:03:49.100
that are available as a regular expression are shown in

75
00:03:49.100 --> 00:03:49.700
this table.

76
00:03:52.300 --> 00:03:55.400
Also to make it very simple we can do validation of

77
00:03:55.400 --> 00:03:58.300
the input using the method marches which is available in the

78
00:03:58.300 --> 00:03:59.600
well-known string class.

79
00:04:00.300 --> 00:04:03.500
Cures an example which explains how the validation can

80
00:04:03.500 --> 00:04:06.500
be done using the marches method in string in

81
00:04:06.500 --> 00:04:09.300
the first statement. The pattern that is passed is

82
00:04:09.300 --> 00:04:12.500
a to z capital A to Z with a space. This is

83
00:04:12.500 --> 00:04:15.400
compared with the string literal Rosie, which returns true

84
00:04:15.400 --> 00:04:19.100
in the last case it Compares with David 234 as

85
00:04:18.100 --> 00:04:21.200
234 is not matching

86
00:04:21.200 --> 00:04:23.200
the pattern it returns false.

87
00:04:26.100 --> 00:04:29.500
The sequence of characters received as input from the user can

88
00:04:29.500 --> 00:04:33.000
be validated against a pattern using character class

89
00:04:32.200 --> 00:04:35.500
quantifiers and met a characters

90
00:04:35.500 --> 00:04:38.200
or just using the matches method in

91
00:04:38.200 --> 00:04:39.000
the string class.

92
00:04:41.800 --> 00:04:44.800
The example code explains how the input received

93
00:04:44.800 --> 00:04:47.800
from the user can be validated by using a combination

94
00:04:47.800 --> 00:04:50.400
of character classes quantifiers and

95
00:04:50.400 --> 00:04:51.100
meta characters.

96
00:04:54.600 --> 00:04:57.600
This is another example for validating an input.

97
00:04:58.200 --> 00:05:01.400
Assume that we get a phone number and that phone number should have

98
00:05:01.400 --> 00:05:04.200
only 10 digits and it should start with digits like

99
00:05:04.200 --> 00:05:05.700
7 8 or 9.

100
00:05:06.400 --> 00:05:09.200
That validation is done in this code. If you

101
00:05:09.200 --> 00:05:12.700
see the pattern the first pattern is given as seven to

102
00:05:12.700 --> 00:05:15.200
nine, which means the first character should be either

103
00:05:15.200 --> 00:05:18.300
7 8 or 9 followed by 0 to 9

104
00:05:18.300 --> 00:05:21.300
within curly brackets. We have given it as 9 which

105
00:05:21.300 --> 00:05:24.600
means 0 to 9 should occur 9 times so it

106
00:05:24.600 --> 00:05:27.700
will accept exactly 10 digits with the first digit

107
00:05:27.700 --> 00:05:29.800
peeing either 7 8 or 9.

108
00:05:32.300 --> 00:05:35.800
After completing this Mortal you wouldn't have learned to understand

109
00:05:35.800 --> 00:05:38.700
regular expression in Java understand

110
00:05:38.700 --> 00:05:41.800
pattern class understand martial class

111
00:05:41.800 --> 00:05:45.400
understand string Methods understand validating

112
00:05:44.400 --> 00:05:45.700
data.

113
00:05:48.200 --> 00:05:48.700
Thank you.
